<?php
// $Id: audio.module,v 1.105.2.12 2007/12/18 00:10:13 drewish Exp $

include(drupal_get_path('module', 'audio') .'/audio_theme.inc');
if (module_exists('views')) {
  include(drupal_get_path('module', 'audio') .'/views_audio.inc');
  include(drupal_get_path('module', 'audio') .'/views_defaults.inc');
}

/**
 * Implementation of hook_help().
 */
function audio_help($section) {
  switch ($section) {
    case 'audio/by':
      return t("You can browse for audio by any of the following fields.");
    case 'admin/help#audio':
      $help  = '<p>'. t('The audio module allows users to upload and store audio files on a Drupal site. Audio is an important medium for community communication as the recent rise of the <a href="!elink-en-wikipedia-org">podcast phenomenon</a> demonstrates.', array('!elink-en-wikipedia-org' => 'http://en.wikipedia.org/wiki/Podcasting')) .'</p>';
      $help .= '<p>'. t('Users create audio nodes by uploading a file from their computer. They are then able to make changes to the metadata, perhaps adding an artist, or removing the track number. Visitors can download the audio file, view the file\'s metadata and encoding information, or browse for audio by metadata (artist, title, year, etc). Visitors can even play MP3s within their browser using the <a href="!elink-musicplayer-sourceforge-net">XSPF flash player</a> that is bundled with the module.', array('!elink-musicplayer-sourceforge-net' => 'http://musicplayer.sourceforge.net/')) .'</p>';
      $help .= '<p>'. t('The module uses the <a href="!elink-www-getid3-org">getID3 library</a> to read and write <a href="%elink-en-wikipedia-org">ID3 tag</a> information from the audio file. getID3 can read metadata from a many different audio and video formats giving the audio module a great deal of flexibility.', array('!elink-www-getid3-org' => 'http://www.getid3.org', '!elink-en-wikipedia-org' => 'http://en.wikipedia.org/wiki/Id3')) .'</p>';
      $help .= t('<p>You can:</p>
                    <ul>
                    <li>add an audio file at <a href="!node-add-audio">create content &gt;&gt; audio</a>.</li>
                    <li>see your most recent audio files at <a href="!user">user account</a>.</li>
                    <li>see all of the most recently added audio files at <a href="!audio">audio</a>.</li>
                    <li>browse for audio by its metadata (artist, album, genre, etc) at <a href="!audio-by">audio &gt;&gt; by</a>.</li>
                    <li>enable the <em>latest audio</em>, <em>random audio</em>, and <em>browse for audio</em> blocks at <a href="!admin-build-block">administer &gt;&gt; build &gt;&gt; block</a>.</li>
                    <li>administer audio module at <a href="!admin-settings-audio">administer &gt;&gt; site configuration &gt;&gt; audio</a>.</li>
                    </ul>', array('!audio' => url('audio'), '!audio-by' => url('audio/by'), '!user' => url('user'), '!node-add-audio' => url('node/add/audio'), '!admin-build-block' => url('admin/build/block'), '!admin-settings-audio' => url('admin/settings/audio/audio')));
      $help .= '<p>'. t('For more information please read the configuration and customization handbook <a href="!audio">Audio page</a>.', array('!audio' => 'http://www.drupal.org/handbook/modules/audio/')) .'</p>';
      return $help;
    case 'admin/settings/audio':
      $help = '<p><b>'. t('The current PHP configuration limits file uploads to %maxsize.', array('%maxsize' => format_size(file_upload_max_size()))) .'</b><br />';
      $help .= '<p>'. t("There are two PHP ini settings, upload_max_filesize and post_max_size, that limit the maximum size of uploads. You can change these settings in the php.ini file or by using a php_value directive in Apache .htaccess file. Consult the PHP documentation for more info.") . '</p>';
      return $help;
    case 'admin/settings/audio/metadata':
      $help = t("These settings let you determine what metadata the audio module tracks. You can add or remove metadata tags and select how they will be used.
        <ul>
        <li><em>Autocompleted</em> enables javacript autocompletion of the tag based on existing values.</li>
        <li><em>Required</em> forces a user to enter a value</li>
        <li><em>Hidden</em> prevents the tag from being listed in the node view</li>
        <li><em>Browsable</em> allows users to browse for audio using that tag</li>
        <li><em>Written to file</em> indicates that the tag should be saved to the file (this requires getid3 support)</li>
        <li><em>Weight</em> determines the order of the tags, lower weights are listed first</li>
        <li><em>Delete</em> indicates that you would like to remove the tag from the allowed list</li>
        </ul>");
      $help .= '<p>'. t('<strong>Note:</strong> deleting a tag will not remove it from the database or file until the node is saved again.') .'</p>';
      return $help;
  }
}

/**
 * Implementation of hook_menu().
 */
function audio_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/audio', 'title' => t('Audio settings'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('audio_admin_settings'),
      'access' => user_access('administer site configuration'),
      'type' => MENU_NORMAL_ITEM,
      'description' => t('Change settings for the audio module.'),
    );
    $items[] = array(
      'path' => 'admin/settings/audio/main', 'title' => t('Audio'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('audio_admin_settings'),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => '-10',
    );
    $items[] = array(
      'path' => 'admin/settings/audio/metadata', 'title' => t('Metadata tags'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('audio_admin_settings_metadata'),
      'type' => MENU_LOCAL_TASK,
    );
    $items[] = array(
      'path' => 'admin/settings/audio/players', 'title' => t('Players'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('audio_admin_settings_players'),
      'type' => MENU_LOCAL_TASK,
    );

    $items[] = array(
      'path' => 'audio/autocomplete',
      'callback' => 'audio_autocomplete',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'audio/by', 'title' => t('Browse by...'),
      'access' => user_access('access content'),
      'type' => MENU_NORMAL_ITEM,
      'callback' => 'audio_page_browse_by',
    );

    $items[] = array(
      'path' => 'audio/download',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
      'callback' => 'audio_download',
    );
    $items[] = array(
      'path' => 'audio/play',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
      'callback' => 'audio_play',
    );
  }
  return $items;
}

/**
 * Implementation of hook_node_info().
 */
function audio_node_info() {
  return array(
    'audio' => array(
      'name' => t('Audio'),
      'module' => 'audio',
      'description' => t('An audio file. The audio file could be used for adding music, podcasts, or audio clips to your site.'),
    )
  );
}

/**
 * Invoke hook_audio api methods.
 *
 * The audio module provide a hook for contributed modules. Use this rather than
 * the nodeapi so you don't have to worry about the module invocation order.
 *
 *   function hook_audio($op, $node, $arg1)
 *
 * @param $op
 *   The $op value will be one of the following:
 *   'load'
 *       An audio node is being loaded.
 *   'prepare'
 *       A node form/preview is being built.
 *   'submit'
 *       A node form is being submitted, before insertion or updates.
 *   'insert'
 *       A new audio node is being created. Changes you make to the node's
 *       audio_images, audio_file, and audio_fileinfo memebers will be saved.
 *   'insert revision'
 *       A new revision of an audio node is being created. Changes you make to
 *       the node's audio_images, audio_file, and audio_fileinfo memebers will
 *       be saved.
 *   'update'
 *       Changes to an audio node are being saved. Changes you make to the
 *       node's audio_images, audio_file, and audio_fileinfo memebers will be
 *       saved.
 *   'delete'
 *       An audio node is being deleted. Remove all of the nodes files and
 *       database records.
 *   'delete revision'
 *       A revision of the audio node is being deleted. Remove any version
 *       specific files or database records.
 *   'upload'
 *       A new audio file has been uploaded. Contrib modules can read data from
 *       the file and append it to the audio node at this point.
 *   'access'
 *       An operation is being performed on the node and other modules can
 *       determine if this will be allowed. $arg1 will describe the operation
 *       (i.e. 'play' or 'download'). Return a boolean if you want to allow or
 *       deny this, or NULL if you don't.
 *   'download'
 *       A user is playing the audio node. This can be handy if you're recording
 *       user statistics.
 *   'play'
 *       A user is downloading an audio node. This can be handy if you're
 *       recording user statistics.
 * @param $node
 *   An audio node object.
 */
function audio_invoke_audioapi($op, &$node, $a3 = NULL, $a4 = NULL) {
  $return = array();
  foreach (module_implements('audio') as $name) {
    $function = $name .'_audio';
    $result = $function($op, $node, $a3, $a4);
    if (isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Implementation of hook_perm().
 */
function audio_perm() {
  return array('administer audio', 'create audio', 'edit own audio',
    'play audio', 'download audio', 'view download stats');
}

/**
 * Implementation of hook_access().
 */
function audio_access($op, $node = NULL) {
  global $user;

  if (user_access('administer audio')) {
    return TRUE;
  }

  if ($op == 'update' || $op == 'delete') {
    if (($user->uid == $node->uid) && user_access('edit own audio')) {
      return TRUE;
    }
  }
  if ($op == 'create') {
    if (user_access('create audio')) {
      return TRUE;
    }
  }
}

/**
 * Is the current user allowed to download an audio node?
 *
 * @return
 *   boolean indicating if it's allowed.
 */
function _audio_allow_download($node) {
  if (isset($node->url_download) && $node->audio_fileinfo['downloadable']) {
    $result = audio_invoke_audioapi('access', $node, 'download');

    if (in_array(TRUE, $result)) {
      return TRUE;
    }
    if (in_array(FALSE, $result)) {
      return FALSE;
    }
    return user_access('download audio');
  }
  return FALSE;
}

/**
 * Is the current user allowed to play an audio node?
 *
 * @return
 *   boolean indicating if it's allowed.
 */
function _audio_allow_play($node) {
  if (isset($node->url_play)) {
    $result = audio_invoke_audioapi('access', $node, 'play');

    if (in_array(TRUE, $result)) {
      return TRUE;
    }
    if (in_array(FALSE, $result)) {
      return FALSE;
    }
    return user_access('play audio');
  }
  return FALSE;
}

/**
 * Implements hook_cron().
 * 
 * This deletes old temp files.
 */
function audio_cron() {
  $path = audio_get_directory() .'/temp';
  $files = file_scan_directory(file_create_path($path), '.*');
  foreach ($files as $file => $info) {
    if (time() - filemtime($file) > 60*60*6) {
      file_delete($file);
    }
  }
}



/**
 * Implementation of hook_link().
 */
function audio_link($type, $node, $main = 0) {
  $links = array();
  $link_access = user_access('view download stats');

  if ($type == 'node' && $node->type == 'audio') {
    if (_audio_allow_download($node)) {
      $links['audio_download_link'] = array(
        'title' => t('Download audio file'),
        'href' => $node->url_download,
      );
      if($link_access){
        $links['audio_download_count'] = array(
          'title' => t('@download_count downloads', array('@download_count' => $node->audio_fileinfo['download_count'])),
        );
      }
    }
    if (_audio_allow_play($node) && $link_access) {
      $links['audio_play_count'] = array(
        'title' => t('@play_count plays', array('@play_count' => $node->audio_fileinfo['play_count'])),
      );
    }
  }

  return $links;
}

/**
 * Implementation of hook_nodeapi().
 */
function audio_nodeapi(&$node, $op, $arg) {
  if ($node->type == 'audio') {
    switch ($op) {
      case 'delete revision':
        audio_delete_revision($node);
        break;

      case 'rss item':
        $ret = array();
        if (_audio_allow_download($node)) {
          // Reset the node's body to remove theming.
          $body = db_result(db_query("SELECT r.body FROM {node} n INNER JOIN {node_revisions} r ON n.nid = r.nid WHERE n.vid=%d", $node->vid));
          $node->body = $body;
          $node = node_prepare($node, FALSE);

          $ret[] = array(
            'key' => 'enclosure',
            'attributes' => array(
              'url' => $node->url_download,
              'length' => $node->audio_file->filesize,
              'type' => $node->audio_file->filemime,
            ));
          // Provide very basic iTunes support.
          $ret[] = array(
            'namespace' => array('itunes' => 'xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"'),
          );
          $ret[] = array(
            'key' => 'itunes:duration',
            'value' => $node->audio_fileinfo['playtime'],
          );
          $ret[] = array(
            'key' => 'itunes:author',
            'value' => $node->audio_tags['artist'],
          );
        }
        return $ret;

      case 'update index':
        // Since the theme might hide the tag values we'll manually add them to
        // the search index.
        $cleantags = array();
        foreach ($node->audio_tags as $value) {
          $cleantags[] = check_plain($value);
        }
        return $cleantags;
    }
  }
}

/**
 * Implementation of hook_view().
 */
function audio_view(&$node, $teaser = FALSE, $page = FALSE) {
  drupal_add_css(drupal_get_path('module','audio') .'/audio.css');

  $node = node_prepare($node, $teaser);
  if ($teaser) {
    $node->content['audio_info'] = array(
      '#value' => theme('audio_teaser', $node),
      '#weight' => 0,
    );
  }
  else {
    $node->content['audio_info'] = array(
      '#value' => theme('audio_display', $node),
      '#weight' => -1,
    );
  }
  return $node;
}

/**
 * Implementation of hook_validate().
 */
function audio_validate(&$node, &$form) {
  $nid = ($node->nid) ? $node->nid : 'new_node';
  if (!isset($node->audio_file) && !isset($_SESSION['audio_file'][$nid])) {
    form_set_error('audio_upload', t("A file must be provided. If you tried uploading a file, make sure it's less than the upload size limit."));
  }

  // Build the title from metadata.
  form_set_value($form['title'], audio_build_title($node));
}

/**
 * Implementation of hook_load().
 */
function audio_load($node) {
  $ret = array();

  if ($node->vid) {
    // Load the audio fields...
    $ret['audio_fileinfo'] = db_fetch_array(db_query("SELECT * FROM {audio} WHERE vid=%d", $node->vid));
    // ... then move some non-file info stuff out of the array
    $ret['title_format'] = $ret['audio_fileinfo']['title_format'];
    unset($ret['audio_fileinfo']['title_format']);

    // Load the file.
    $result = db_query('SELECT origname, filename, filepath, filemime, filesize FROM {audio_file} f WHERE f.vid = %d', $node->vid);
    $ret['audio_file'] = $file = db_fetch_object($result);
    $ret['audio_fileinfo']['filesize'] = $file->filesize;

    if (file_exists($file->filepath)) {
      // TODO: should these links be by vid?
      $ret['url_play'] = url('audio/play/'. $node->nid, NULL, NULL, TRUE);
      if ($ret['audio_fileinfo']['downloadable']) {
        // iTunes and other podcasting programs check the url to determine the
        // file type. we'll add the original file name on to the end. see issues
        // #35398 and #68716 for more info.
        $url = 'audio/download/'. $node->nid .'/'. $file->origname;
        $ret['url_download'] = url($url , NULL, NULL, TRUE);
      }
    }

    // Load the audio tags.
    $result = db_query("SELECT tag, value FROM {audio_metadata} WHERE vid=%d", $node->vid);
    $ret['audio_tags'] = array();
    while ($obj = db_fetch_object($result)) {
      $ret['audio_tags'][$obj->tag] = $obj->value;
    }

    // Allow other modules to access newly loaded audio node.
    $ret = array_merge($ret, audio_invoke_audioapi('load', $node));
  }

  return $ret;
}

/**
 * Implementation of hook_insert().
 */
function audio_insert(&$node) {
  // the original filename is preserved in the name field so we can avoid name
  // collisions but restore the original name when they download it.
  $node->audio_file->origname = $node->audio_file->filename;

  file_move($node->audio_file, audio_get_directory(), FILE_EXISTS_RENAME);

  // Notify other modules.
  audio_invoke_audioapi('insert', $node);

  $f = $node->audio_file;
  $i = $node->audio_fileinfo;
  db_query("INSERT INTO {audio_file} (vid, origname, filename, filepath, filemime, filesize) VALUES (%d, '%s', '%s', '%s', '%s', %d)",
    $node->vid, $f->origname, basename($f->filepath), $f->filepath, $f->filemime, filesize($f->filepath));
  db_query("INSERT INTO {audio} (vid, nid, title_format, downloadable, fileformat, bitrate, bitrate_mode, sample_rate, channel_mode, playtime) VALUES (%d, %d, '%s', %d, '%s', %f, '%s', %d, '%s', '%s')",
    $node->vid, $node->nid, $node->title_format, $i['downloadable'], $i['fileformat'], $i['bitrate'], $i['bitrate_mode'], $i['sample_rate'], $i['channel_mode'], $i['playtime']);

  _audio_save_tags_to_db($node);

  // Unset the new file flag incase this node is re-saved.
  unset($node->audio_file->newfile);
}

/**
 *  Insert a new node revision. 
 *
 * If a new file wasn't uploaded, make a copy of the existing file.
 */
function audio_insert_revision($node) {
  $directory = audio_get_directory();

  // new file uploaded?
  if (isset($node->audio_file->newfile)) {
    // the original filename is preserved in the name field so we can avoid name
    // collisions but restore the original name when they download it.
    $node->audio_file->origname = $node->audio_file->filename;

    file_move($node->audio_file, audio_get_directory(), FILE_EXISTS_RENAME);
  }
  else {
    $newname = file_create_filename($node->audio_file->filename, audio_get_directory());
    file_copy($node->audio_file, $newname);
  }

  // Notify other modules.
  audio_invoke_audioapi('insert revision', $node);

  $f = $node->audio_file;
  $i = $node->audio_fileinfo;
  db_query("INSERT INTO {audio_file} (vid, origname, filename, filepath, filemime, filesize) VALUES (%d, '%s', '%s', '%s', '%s', %d)",
    $node->vid, $f->origname, basename($f->filepath), $f->filepath, $f->filemime, filesize($f->filepath));
  db_query("INSERT INTO {audio} (vid, nid, title_format, downloadable, fileformat, bitrate, bitrate_mode, sample_rate, channel_mode, playtime) VALUES (%d, %d, '%s', %d, '%s', %f, '%s', %d, '%s', '%s')",
    $node->vid, $node->nid, $node->title_format, $i['downloadable'], $i['fileformat'], $i['bitrate'], $i['bitrate_mode'], $i['sample_rate'], $i['channel_mode'], $i['playtime']);

  // add the tags records
  _audio_save_tags_to_db($node);
}

/**
 * Implementation of hook_update().
 */
function audio_update(&$node) {
  // Check for new revsion.
  if ($node->revision) {
    return audio_insert_revision($node);
  }

  if (isset($node->audio_file->newfile)) {
    unset($node->audio_file->newfile);

    // remove the old file
    $oldfile = db_fetch_object(db_query('SELECT filepath FROM {audio_file} f WHERE f.vid = %d', $node->vid));
    file_delete($oldfile->filepath);

    // Save the new one.
    // TODO: better error checking that the move works...
    file_move($node->audio_file, audio_get_directory(), FILE_EXISTS_RENAME);
  }

  // Notify other modules.
  audio_invoke_audioapi('update', $node);

  // Do a delete and insert rather than an update to ensure that we've got db
  // records. it takes a bit longer but it allows us to carry on if one of the
  // records wasn't created by audio_insert().
  db_query("DELETE FROM {audio} WHERE vid=%d", $node->vid);
  db_query("DELETE FROM {audio_file} WHERE vid=%d", $node->vid);

  $i = $node->audio_fileinfo;
  $f = $node->audio_file;
  db_query("INSERT INTO {audio} (vid, nid, title_format, play_count, download_count, downloadable, fileformat, bitrate, bitrate_mode, sample_rate, channel_mode, playtime) VALUES (%d, %d, '%s', %d, %d, %d, '%s', %f, '%s', %d, '%s', '%s')",
    $node->vid, $node->nid, $node->title_format, $i['play_count'], $i['download_count'], $i['downloadable'], $i['fileformat'], $i['bitrate'], $i['bitrate_mode'], $i['sample_rate'], $i['channel_mode'], $i['playtime']);
  db_query("INSERT INTO {audio_file} (vid, origname, filename, filepath, filemime, filesize) VALUES (%d, '%s', '%s', '%s', '%s', %d)",
    $node->vid, $f->origname, basename($f->filepath), $f->filepath, $f->filemime, filesize($f->filepath));

  _audio_save_tags_to_db($node);
}

/**
 * Implementation of hook_delete().
 */
function audio_delete($node) {
  // Notify other modules.
  audio_invoke_audioapi('delete', $node);

  $result = db_query('SELECT vid FROM {audio} WHERE nid = %d', $node->nid);
  while ($o = db_fetch_object($result)) {
    if ($filepath = db_result(db_query('SELECT filepath FROM {audio_file} WHERE vid = %d', $o->vid))) {
      file_delete($filepath);
    }
    db_query('DELETE FROM {audio_metadata} WHERE vid = %d', $o->vid);
    db_query('DELETE FROM {audio_file} WHERE vid = %d', $o->vid);
  }
  db_query('DELETE FROM {audio} WHERE nid = %d', $node->nid);
}

/**
 * Delete a single revision.
 */
function audio_delete_revision($node) {
  // Notify other modules.
  audio_invoke_audioapi('delete revision', $node);

  if ($filepath = db_result(db_query('SELECT filepath FROM {audio_file} WHERE vid = %d', $node->vid))) {
    file_delete($filepath);
  }

  db_query('DELETE FROM {audio_metadata} WHERE vid = %d', $node->vid);
  db_query('DELETE FROM {audio_file} WHERE vid = %d', $node->vid);
  db_query('DELETE FROM {audio} WHERE vid = %d', $node->vid);
}

/**
 * Implementation of hook_prepare().
 * 
 * We do a lot here because we need to read the file's meta data after upload
 * but before both the form and node preview are built.
 */
function audio_prepare(&$node) {
  // We need to be aware that a user may try to edit multiple audio nodes at
  // once. By using the $nid variable each node's files can be stored separately
  // in the session.
  $nid = ($node->nid) ? $node->nid : 'new_node';
  // When you enter the edit view the first time we need to clear our files in
  // session for this node. This is so if you upload a file, then decide you
  // don't want it and reload the form (without posting), the files will be
  // discarded.
  if(count($_POST) == 0) {
    unset($_SESSION['audio_file'][$nid]);
  }

  // Check for an upload.
  if ($file = file_check_upload('audio_upload')) {
    // Check for valid file extensions...
    $extensions = variable_get('audio_allowed_extensions', 'mp3 wav ogg');
    $regex = '/\.('. ereg_replace(' +', '|', preg_quote($extensions)) .')$/i';
    if (!preg_match($regex, $file->filename)) {
      //set an error message and delete the the file
      form_set_error('audio', t('The selected file %name can not be uploaded, because it is only possible to upload files with the following extensions: %files-allowed.', array('%name' => $file->filename, '%files-allowed' => $extensions)));
      file_delete($file->filepath);
    }
    else {
      // Save the upload into Drupal's temp directory.
      $temppath = file_directory_temp() . '/audio/';
      file_check_directory($temppath, TRUE);

      $node->audio_file = file_save_upload($file, $temppath .'/'. $file->filename, FILE_EXISTS_REPLACE);
      $node->audio_file->origname = $file->filename;
      $node->audio_file->newfile = TRUE;

      $node->audio_tags = array();

      $node->audio_fileinfo = array(
        'play_count' => 0,
        'download_count' => 0,
        'filesize' => filesize($node->audio_file->filepath),
        'downloadable' => (bool) $_POST['audio_fileinfo']['downloadable'],
      );

      // Allow other modules to modify the node.
      audio_invoke_audioapi('upload', $node);

      // ...save info to $_POST so that it shows up in both the preview and
      // form. Note that we do this after calling we called our api hook with
      // the upload operation, it gives the audio_id3 module a chance to read
      // the tags.
      $_POST['audio_fileinfo'] = $node->audio_fileinfo;
      $_POST['audio_tags'] = $node->audio_tags;

      $_SESSION['audio_file'][$nid] = $node->audio_file;
    }
  }

  if (!empty($_SESSION['audio_file'][$nid])) {
    $node->audio_file = $_SESSION['audio_file'][$nid];
  }
  else {
    $_SESSION['audio_file'][$nid] = $node->audio_file;
  }

  audio_invoke_audioapi('prepare', $node);
}

/**
 * Implementation of hook_form().
 */
function audio_form(&$node) {
  $type = node_get_types('type', $node);

  if ($type->has_title) {
    $form['title_format'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#default_value' => isset($node->title_format) ? $node->title_format : variable_get('audio_default_title_format', '!title by !artist'),
      '#description' => t("The title can use the file's metadata. Depending on what's filled out, you maybe able to use any of the following variables: " ) .'!filename !'. implode(' !', audio_get_tags_allowed()),
      '#required' => TRUE,
      '#weight' => -5,
    );
  }

  if ($type->has_body) {
    $form['body_filter']['#weight'] = -4;
    $form['body_filter']['body'] = array(
      '#type' => 'textarea',
      '#title' => check_plain($type->body_label),
      '#default_value' => $node->body,
      '#rows' => 5,
      '#required' => ($type->min_word_count > 0),
      );
    $form['body_filter']['format'] = filter_form($node->format);
  }

  $form['#attributes'] = array('enctype' => 'multipart/form-data');
  $form['audio_fileinfo'] = array(
    '#type' => 'fieldset',
    '#title' => t('Audio File Info'),
    '#collapsible'=> TRUE,
    '#weight' => -1,
    '#tree' => TRUE,
  );
  $form['audio_fileinfo']['filepath'] = array(
    '#type' => 'item',
    '#title' => t('Current File'),
    '#value' => t('No file is attached.'),
    '#weight' => -1,
  );
  $form['audio_fileinfo']['audio_upload'] = array(
    '#tree' => FALSE, 
    '#type' => 'file',
    '#title' => t('Add a new audio file'),
    '#description' => t('Click "Browse..." to select an audio file to upload. Only files with the following extensions are allowed: %allowed-extensions.', array('%allowed-extensions' => variable_get('audio_allowed_extensions', 'mp3 wav ogg'))) .'<br />'
      . t('<strong>NOTE:</strong> the current PHP configuration limits uploads to %maxsize.', array('%maxsize' => format_size(file_upload_max_size()))),
    '#weight' => 19,
  );
  $form['audio_fileinfo']['downloadable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow file downloads.'),
    '#default_value' => isset($node->audio_fileinfo['downloadable']) ? $node->audio_fileinfo['downloadable'] : variable_get('audio_default_downloadable', 1),
    '#description' => t('If checked, a link will be displayed allowing visitors to download this audio file on to their own computer.') .'<br />'
      . t('<strong>WARNING:</strong> even if you leave this unchecked, clever users will be able to find a way to download the file. This just makes them work a little harder to find the link.'),
    '#weight' => 20,
  );


  // If we've got a file, add the fields for editing meta data and displaying
  // the file's info.
  if (isset($node->audio_file)) {
    $form['audio_tags'] = array(
      '#type' => 'fieldset',
      '#title' => t('Audio Metadata'),
      '#collapsible'=> TRUE,
      '#tree' => TRUE,
      '#weight' => -3,
    );
    // Delegate out the dirty work of building form elements.
    foreach (audio_get_tag_settings() as $tag => $tag_settings) {
      $form['audio_tags'][$tag] = _audio_build_tag_form($tag, $tag_settings, $node->audio_tags[$tag]);
    }

    // Hide the directory information from non-admins.
    $file_path = $node->audio_file->filepath;
    if (!user_access('administer audio')) {
      $file_path = basename($file_path);
    }
    $form['audio_fileinfo']['filepath']['#value'] = $file_path;
    $form['audio_fileinfo']['audio_upload']['#title'] = t('Replace this with a new file');
    $form['audio_fileinfo']['fileformat'] = array(
      '#type' => 'select',
      '#title' => t('Format'),
      '#default_value' => $node->audio_fileinfo['fileformat'],
      '#options' => drupal_map_assoc(array('', 'aac', 'ac3', 'au', 'avr', 'flac', 'midi', 'mod', 'mp3', 'mpc', 'ogg', 'voc'), 'drupal_strtoupper'),
    );
    $form['audio_fileinfo']['filesize'] = array(
      '#type' => 'textfield',
      '#title' => t('Size (in bytes)'),
      '#default_value' => $node->audio_fileinfo['filesize'],
    );
    $form['audio_fileinfo']['playtime'] = array(
      '#type' => 'textfield',
      '#title' => t('Length'),
      '#default_value' => $node->audio_fileinfo['playtime'],
      '#description' => t('The format is hours:minutes:seconds.'),
    );
    $form['audio_fileinfo']['sample_rate'] = array(
      '#type' => 'select',
      '#title' => t('Sample rate'),
      '#default_value' => $node->audio_fileinfo['sample_rate'],
      '#options' => array('' => '', '48000' => '48,000 Hz', '44100' => '44,100 Hz', '32000' => '32,000 Hz', '22050' => '22,050 Hz', '11025' => '11,025 Hz', '8000' => '8,000 Hz',),
    );
    $form['audio_fileinfo']['channel_mode'] = array(
      '#type' => 'select',
      '#title' => t('Channel mode'),
      '#default_value' => $node->audio_fileinfo['channel_mode'],
      '#options' => array('stereo' => t('Stereo'), 'mono' => t('Mono'),),
    );
    $form['audio_fileinfo']['bitrate'] = array(
      '#type' => 'textfield',
      '#title' => t('Bitrate'),
      '#default_value' => $node->audio_fileinfo['bitrate'],
    );
    $form['audio_fileinfo']['bitrate_mode'] = array(
      '#type' => 'textfield',
      '#title' => t('Bitrate mode'),
      '#default_value' => $node->audio_fileinfo['bitrate_mode'],
    );

    // Users shouldn't be able to change the play and download counts so we'll
    // put these for viewing...
    $form['audio_fileinfo']['display_play_count'] = array(
      '#type' => 'item',
      '#title' => t('Play count'),
      '#value' => $node->audio_fileinfo['play_count'],
    );
    $form['audio_fileinfo']['display_download_count'] = array(
      '#type' => 'item',
      '#title' => t('Download count'),
      '#value' => $node->audio_fileinfo['download_count'],
    );
    // ...and these are what we'll save back to the node.
    $form['audio_fileinfo']['play_count'] = array(
      '#type' => 'value',
      '#value' => $node->audio_fileinfo['play_count'],
    );
    $form['audio_fileinfo']['download_count'] = array(
      '#type' => 'value',
      '#value' => $node->audio_fileinfo['download_count'],
    );
  }

  return $form;
}

/**
 * Construct a form element to represent a tag.
 *
 * @param $tag
 *   Name of the tag.
 * @param $tag_settings
 *   Array of settings that determine the way the tag is handled.
 * @param $value
 *   Value of the tag.
 * @return
 *  Array with a form element.
 */
function _audio_build_tag_form($tag, $tag_settings, $value) {
  $form_element = array(
    '#type' => 'textfield',
    '#title' => t(ucwords(str_replace('_', ' ', $tag))),
    '#default_value' => $value,
    '#maxlength' => 255,
    '#required' => (boolean) $tag_settings['required'],
  );

  if ($tag_settings['autocomplete']) {
    $form_element['#autocomplete_path'] = 'audio/autocomplete/'. $tag;
  }

  switch ($tag) {
    case 'track':
      $form_element['#title'] = t('Track Number');
      $form_element['#maxlength'] = 10;
      $form_element['#description'] = t("Enter either a single number or fraction here. '1' means that this is the first track on the album, and '1/8' .");
      break;

    case 'genre':
      $form_element['#maxlength'] = 40;
      break;
  }

  return $form_element;
}

/**
 * Implementation of hook_submit().
 */
function audio_submit(&$node) {
  // Use the the file was stored in the session during audio_prepare().
  $nid = ($node->nid) ? $node->nid : 'new_node';
  if (isset($_SESSION['audio_file'][$nid])) {
    $node->audio_file = $_SESSION['audio_file'][$nid];
    unset($_SESSION['audio_file'][$nid]);
  }
  audio_invoke_audioapi('submit', $node);
}

/**
 * Build a title for the node.
 *
 * @param $node
 *   Node object with title_format and audio_tags values.
 * @return
 *   String with node's title.
 */
function audio_build_title($node) {
  // If there's not title format use the default.
  if (!isset($node->title_format)) {
    $node->title_format = variable_get('audio_default_title_format', '!title by !artist');
  }

   // Build a list of parameters.
  $params = array(
    '!filename' => $node->audio_file->filename,
  );
  foreach (audio_get_tags_allowed() as $tag) {
    $params['!'. $tag] = isset($node->audio_tags[$tag]) ? $node->audio_tags[$tag] : '';
  }

  return t($node->title_format, $params);
}

/**
 * Implementation of hook_user().
 */
function audio_user($op, &$edit, &$user, $category = NULL) {
  if ($op == 'view') {
    $result = db_query(db_rewrite_sql("SELECT COUNT(*) FROM {node} n WHERE n.type = 'audio' AND n.uid = %d AND n.status = 1"), $user->uid);
    if (db_result($result) > 0) {
      $items['audio'] = array(
        'title' => t('Audio'),
        'value' => l(t("Listen to @username's recent audio files", array('@username' => $user->name)), 'audio/user/'. $user->uid),
        'class' => 'audio',
      );
      return array(t('History') => $items);
    }
  }
}

/**
 * Implementation of hook_block().
 *
 * Provides a block for browsing by metadata.
 */
function audio_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks[2]['info'] = t('audio: Browse by');
      return $blocks;

    case 'view':
      if (user_access('access content')) {
        switch($delta) {
          case 2:
            $items = array();
            $settings = audio_get_tag_settings();
            $result = db_query(db_rewrite_sql('SELECT DISTINCT a.tag FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE n.status = 1 ORDER BY a.tag ASC'));
            while ($obj = db_fetch_object($result)) {
              if ($settings[$obj->tag]['browsable']) {
                $items[] = l($obj->tag, 'audio/by/'. $obj->tag);
              }
            }
            $block['subject'] = t('Browse for audio by');
            $block['content'] = theme('item_list', $items);
            break;
        }
        return $block;
      }
  }
}


/**
 * Settings form.
 */
function audio_admin_settings() {
  $form['audio_default_title_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Default node title format'),
    '#maxlength' => 128,
    '#default_value' => variable_get('audio_default_title_format', '!artist - !title'),
    '#description' => t("The audio node's title can use the file's metadata as variables. This will be used as the default title for all new audio nodes. The following values can be used: ") .'!filename !'. implode(' !', audio_get_tags_allowed()),
  );
  $form['audio_teaser_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Node teaser format'),
    '#maxlength' => 128,
    '#default_value' => variable_get('audio_teaser_format', '!player<br />!filelength'),
    '#description' => t("Specify a teaser format for all audio nodes. In addition to the tags allowed in the title, the following variables are also available: "). '!filelength !fileformat !player',
  );
  $form['audio_allowed_extensions'] = array(
    '#type' => 'textfield',
    '#title' => t('Permitted audio file extensions'),
    '#maxlength' => 128,
    '#default_value' => variable_get('audio_allowed_extensions', 'mp3 wav ogg'),
    '#description' => t('Audio file extensions that users can upload. Separate extensions with a space and do not include a leading dot.'),
  );
  $form['audio_default_downloadable'] = array(
    '#type' => 'checkbox',
    '#title' => t("Downloadable by default"),
    '#default_value' => variable_get('audio_default_downloadable', 1),
    '#description' => t('Check this to make downloadable the default setting for new audio nodes. You should be aware that even when audio is not marked as downloadable, clever users can still download it, this just makes the work harder. '),
  );

  return system_settings_form($form);
}

/**
 * The ID3 tag settings page.
 */
function audio_admin_settings_metadata() {
  $settings = audio_get_tag_settings();
  $form['audio_tag_settings'] = array('#tree' => TRUE);
  foreach ($settings as $tag => $setting) {
    $form['audio_tag_settings'][$tag]['name'] = array(
      '#type' => 'item',
      '#value' => $tag
    );
    $form['audio_tag_settings'][$tag]['autocomplete'] = array(
      '#type' => 'checkbox',
      '#default_value' => $setting['autocomplete']
    );
    $form['audio_tag_settings'][$tag]['required'] = array(
      '#type' => 'checkbox',
      '#default_value' => $setting['required'],
    );
    $form['audio_tag_settings'][$tag]['hidden'] = array(
      '#type' => 'checkbox',
      '#default_value' => $setting['hidden'],
    );
    $form['audio_tag_settings'][$tag]['browsable'] = array(
      '#type' => 'checkbox',
      '#default_value' => $setting['browsable'],
    );
    $form['audio_tag_settings'][$tag]['writetofile'] = array(
      '#type' => 'checkbox',
      '#default_value' => $setting['writetofile'],
    );
    $form['audio_tag_settings'][$tag]['weight'] = array(
      '#type' => 'weight',
      '#default_value' => $setting['weight']
    );
  }
  $deleteOptions = array();
  foreach($settings as $tag => $setting) {
    $deleteOptions[$tag] = '';
  }
  $form['delete'] = array(
    '#type' => 'checkboxes',
    '#options' => $deleteOptions,
  );

  // Add in a row for a new tag.
  $form['audio_tag_settings']['new']['name'] = array(
    '#type' => 'textfield',
    '#size' => 15,
    '#maxlength' => 45,
  );
  $form['audio_tag_settings']['new']['autocomplete'] = array(
    '#type' => 'checkbox',
    '#default_value' => TRUE,
  );
  $form['audio_tag_settings']['new']['required'] = array(
    '#type' => 'checkbox',
    '#default_value' => FALSE,
  );
  $form['audio_tag_settings']['new']['hidden'] = array(
    '#type' => 'checkbox',
    '#default_value' => FALSE,
  );
  $form['audio_tag_settings']['new']['browsable'] = array(
    '#type' => 'checkbox',
    '#default_value' => TRUE,
  );
  $form['audio_tag_settings']['new']['writetofile'] = array(
    '#type' => 'checkbox',
    '#default_value' => FALSE,
  );
  $form['audio_tag_settings']['new']['weight'] = array(
    '#type' => 'weight',
    '#default_value' => 0,
  );

  return system_settings_form($form);
}

/**
 * Save the ID3 tag settings, we can't use system_settings_form_submit() as the
 * form callback because it wouldn't call theme_audio_settings().
 */
function audio_admin_settings_metadata_submit($form_id, $form_values) {
  $op = isset($_POST['op']) ? $_POST['op'] : '';

  if ($op == t('Reset to defaults')) {
    variable_del('audio_tag_settings');
    drupal_set_message(t('The configuration options have been reset to their default values.'));
  }
  else {
    // Remove any deleted tags.
    foreach ($form_values['delete'] as $field) {
      if ($field) {
        unset($form_values['audio_tag_settings'][$field]);
      }
    }
    // If there's a new tag, add it in.
    if ($form_values['audio_tag_settings']['new']['name']) {
      $name = $form_values['audio_tag_settings']['new']['name'];
      $form_values['audio_tag_settings'][$name] = $form_values['audio_tag_settings']['new'];
    }
    unset($form_values['audio_tag_settings']['new']);

    // Sort by the weight and then by name of the tag. I'm sure there's a
    // better way to do this...
    foreach ($form_values['audio_tag_settings'] as $tag => $settings) {
      $weights[$tag] = $settings['weight'];
      $names[$tag] = $tag;
    }
    array_multisort($weights, SORT_ASC, SORT_NUMERIC, $names, SORT_ASC, SORT_STRING);
    $audio_tag_settings = array();
    foreach ($names as $tag) {
      $audio_tag_settings[$tag] = $form_values['audio_tag_settings'][$tag];
    }

    // ...and save it.
    variable_set('audio_tag_settings', $audio_tag_settings);

    drupal_set_message(t('The configuration options have been saved.'));
  }
}

/**
 * Format the id3tags settings form as a table.
 */
function theme_audio_admin_settings_metadata($form) {
  $rows = array();
  foreach (element_children($form['audio_tag_settings']) as $key) {
    $row = array();
    if (is_array($form['audio_tag_settings'][$key]['name'])) {
      $row[] = drupal_render($form['audio_tag_settings'][$key]['name']);
      $row[] = drupal_render($form['audio_tag_settings'][$key]['autocomplete']);
      $row[] = drupal_render($form['audio_tag_settings'][$key]['required']);
      $row[] = drupal_render($form['audio_tag_settings'][$key]['hidden']);
      $row[] = drupal_render($form['audio_tag_settings'][$key]['browsable']);
      $row[] = drupal_render($form['audio_tag_settings'][$key]['writetofile']);
      $row[] = drupal_render($form['audio_tag_settings'][$key]['weight']);

      $row[] = drupal_render($form['delete'][$key]);
    }
    $rows[] = $row;
  }
  $header = array(t('Tag'), t('Autocompleted'), t('Required'), t('Hidden'), t('Browsable'),
    t('Written to file'), t('Weight'), t('Delete'));

  $output = theme('table', $header, $rows);
  $output .= drupal_render($form);
  return $output;
}

/**
 * Form for player settings.
 */
function audio_admin_settings_players() {
  $form = array();

  $options = array();
  foreach (audio_get_players('formats') as $format => $players) {
    foreach ($players as $id => $player) {
      $options[$id] = $player['title'];
      $form['players'][$format][$id]['description'] = array(
        '#type' => 'item',
        '#title' => t('Description'),
        '#value' => $player['description'],
      );
      $form['players'][$format][$id]['url'] = array(
        '#type' => 'item',
        '#title' => t('URL'),
        '#value' => $player['url'],
      );
      $form['players'][$format][$id]['preview'] = array(
        '#type' => 'item',
        '#title' => t('URL'),
        '#value' => drupal_get_path('module', $player['module']) .'/'. $player['preview'],
      );
    }
    $form['audio_player_'. $format] = array(
      '#type' => 'radios',
      '#title' => t('Player'),
      '#default_value' => variable_get('audio_player_'. $format, '1pixelout'),
      '#options' => $options,
    );
  }
  return system_settings_form($form);
}

function theme_audio_admin_settings_players($form) {
  $output = '';
  $header = array(t('Player'), t('Description'), t('Homepage'));
  foreach (element_children($form['players']) as $format) {
    $output .= '<h2>'. t('%format files', array('%format' => $format)) .'</h2>';
    $rows = array();
    foreach (element_children($form['players'][$format]) as $name) {
      $rows[] = array(
        drupal_render($form['audio_player_'. $format][$name])
          . theme('image', $form['players'][$format][$name]['preview']['#value'], 'preview', 'preview'),
        check_plain($form['players'][$format][$name]['description']['#value']),
        l(t('Link'), $form['players'][$format][$name]['url']['#value']),
      );
      unset($form['players'][$format][$name]['description']);
      unset($form['players'][$format][$name]['url']);
      unset($form['players'][$format][$name]['preview']);
    }
    unset($form['audio_player_'. $format]);
    $output .= theme('table', $header, $rows);
  }
  return $output . drupal_render($form);
}

/**
 * Get an array of the allowed tags.
 *
 * @return
 *   Array of allowed tags.
 */
function audio_get_tags_allowed() {
  return array_keys(audio_get_tag_settings());
}

/**
 * Get an array of the tags and their settings.
 *
 * @return
 *   Array of allowed tags.
 */
function audio_get_tag_settings() {
  $defaults = array(
    'artist' => array('autocomplete' => 1, 'required' => 1, 'hidden' => 0,
      'writetofile' => 1, 'browsable' => 1, 'weight' => -2),
    'title'  => array('autocomplete' => 1, 'required' => 1, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => -2),
    'album'  => array('autocomplete' => 1, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => -1),
    'track'  => array('autocomplete' => 0, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 0, 'weight' => -1),
    'genre'  => array('autocomplete' => 1, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => 0),
    'year'   => array('autocomplete' => 0, 'required' => 0, 'hidden' => 0,
       'writetofile' => 1, 'browsable' => 1, 'weight' => 1),
  );
  return variable_get('audio_tag_settings', $defaults);
}

/**
 * Retrieve autocomplete suggestions for existing audio metadata tags.
 *
 * @param $tag
 *   tag listed in audio_get_tag_settings() where autocomplete is true.
 * @param $value
 *   partial tag value to try to find in the database.
 */
function audio_autocomplete($tag = '', $value = '') {
  $matches = array();
  $tags = audio_get_tag_settings();
  if (isset($tags[$tag]) && $tags[$tag]['autocomplete']) {
    $result = db_query_range("SELECT DISTINCT a.value FROM {audio_metadata} a WHERE a.tag = '%s' AND LOWER(a.value) LIKE LOWER('%s%%') ORDER BY a.value", $tag, $value, 0, 10);
    while ($tag = db_fetch_object($result)) {
      $matches[$tag->value] = check_plain($tag->value);
    }
  }
  print drupal_to_js($matches);
  exit();
}

/**
 * Get the audio files directory.
 *
 * @return
 *   string path to the audio directory
 */
function audio_get_directory() {
  // We have to make sure the files directory exists first...
  $dir = file_directory_path();
  file_check_directory($dir, FILE_CREATE_DIRECTORY, 'made up element name');
  // ...then that our audio sub-directory exists.
  $dir .= '/audio';
  file_check_directory($dir, FILE_CREATE_DIRECTORY, 'made up element name');

  return $dir;
}

/**
 * Provide a way to browse the audio by metadata.
 *
 * @param $tag
 *   ID3 tag name.
 * @param $value
 *   Value of the tag. It'll be "cleaned" of non-alphanumeric values characters
 *   comparing it.
 */
function audio_page_browse_by($tag = NULL, $value = NULL) {
  $breadcrumb = array(l(t('Audio'), 'audio'));

  if (isset($tag)) {
    $breadcrumb[] = l(t('Browse by'), 'audio/by');

    if (isset($value)) {
      drupal_set_title(t("audio by @tag %value", array('@tag' => $tag, '%value' => trim(str_replace('_', ' ', $value)))));

      $result = db_query(db_rewrite_sql("SELECT n.nid, n.title, a.tag, a.value FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE a.tag = '%s' AND a.clean = '%s' AND n.status = 1 ORDER BY n.created ASC"), $tag, audio_clean_tag($value));
      $breadcrumb[] = l(t('@tag', array('@tag' => $tag)), 'audio/by/'. $tag);

      $output = '';
      while ($obj = db_fetch_object($result)) {
        if ($node = node_load($obj->nid)) {
          $output .= node_view($node, TRUE);
        }
      }
    }
    else {
      drupal_set_title(t("Audio by @tag", array('@tag' => $tag)));

      $result = db_query(db_rewrite_sql("SELECT a.value, a.clean, COUNT(a.clean) AS count FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE a.tag = '%s' AND n.status = 1 GROUP BY a.value, a.clean ORDER BY a.value ASC"), $tag);
      while ($obj = db_fetch_object($result)) {
        $items[] = l($obj->value, "audio/by/{$tag}/{$obj->clean}") ." ({$obj->count})";
      }
      $output = theme('item_list', $items);
    }
  }
  else {
    drupal_set_title(t("Browse for audio by..."));

    $settings = audio_get_tag_settings();
    $result = db_query(db_rewrite_sql('SELECT DISTINCT a.tag FROM {node} n INNER JOIN {audio_metadata} a ON n.vid = a.vid WHERE n.status = 1 ORDER BY a.tag ASC'));
    while ($obj = db_fetch_object($result)) {
      if ($settings[$obj->tag]['browsable']) {
        $items[] = l($obj->tag, 'audio/by/'. $obj->tag);
      }
    }
    $output = theme('item_list', $items);
  }

  drupal_set_breadcrumb($breadcrumb);

  return $output;
}

/**
 * Loads the player plugs-ins and returns their details.  
 *
 * @return
 *   Array with two sub arrays. The first keyed by player name, the second
 *   keyed by format and then player name. The same player may be listed for 
 *   multiple formats.
 */
function _audio_player_build_list() {
  // Invoke any modules that implement the hook.
  $players_name = module_invoke_all('audio_player');

  // Load all our module's player plugins.
  $path = drupal_get_path('module', 'audio') .'/players';
  $files = drupal_system_listing('.inc$', $path, 'name', 0);
  foreach ($files as $file) {
    require_once('./' . $file->filename);
    $function = 'audio_' . $file->name . '_audio_player';
    if (function_exists($function)) {
      $result = $function();
      if (isset($result) && is_array($result)) {
        $players_name = array_merge($players_name, $result);
      }
    }
  }

  // Group players by format.
  $players_format = array();
  foreach ($players_name as $name => $player) {
    foreach ($player['formats'] as $format) {
      $players_format[$format][$name] = $player;
    }
  }

  return array($players_name, $players_format);
}

/**
 * Return information on the installed player plugins.
 *
 * @param $op
 *   String specifying the operation. Possible values are:
 *     'formats'
 *     'format'
 *     'names'
 *     'name'
 * @param $name
 *   Name of a specific player, used with $op = 'format' or 'name'.
 */
function audio_get_players($op = 'names', $name = '') {
  static $_player_name, $_player_format;

  if (!isset($_player_format)) {
    list($_player_name, $_player_format) = _audio_player_build_list();
  }

  switch ($op) {
    case 'formats':
      return $_player_format;
    case 'format':
      if (isset($_player_format[$name])) {
        return $_player_format[$name];
      }
      return FALSE;
    case 'names':
      return $_player_name;
    case 'name':
      if (isset($_player_name[$name])) {
        return $_player_name[$name];
      }
      return FALSE;
    default:
      return FALSE;
  }
}

/**
 * Build HTML to play an audio node.
 *
 * @param $node
 *   Node object.
 * @param $playername
 *   Optional, string specifying the name of the desired player.
 * @return
 *   HTML to play the audio tracks.
 */
function audio_get_node_player($node, $playername = NULL) {
  $output = '';

  if (_audio_allow_play($node)) {
    $format = $node->audio_fileinfo['fileformat'];
    if (!isset($playername)) {
      $playername = variable_get('audio_player_'. $format, '1pixelout');
    }
    $player = audio_get_players('name', $playername);
    // Try to use the requested player...
    $output = theme($player['theme_node'], $node);
    if (!$output) {
      // ...if that doesn't work out, use the generic one.
      $output = theme('audio_default_node_player', $node);
    }
  }
  return $output;
}

/**
 * Provide a link to the audio file.
 *
 * @param $node
 *   Node object.
 */
function theme_audio_default_node_player($node) {
  return '<span class="audio">' . l(t('Click to play'), $node->url_play) ."</span>\n";
}

/**
 * Take a tag and force it to be a-z 0-9 _ -
 *
 * @param $string
 *   ID3 tag value
 * @return
 *   cleaned up tag value for URL or database
 */
function audio_clean_tag($string) {
  // If we've got characters besides 0-9 A-Z a-z hyphen and underscore, replace 
  // them.
  if (preg_match('/[^-\w]/', $string)) {
    // Remove accents...
    $string = strtr($string, '������������������������������������������������������������', 'SZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy');
    // ...convert to equivalent chars...
    $string = strtr($string, array('�' => 'TH', '�' => 'th', '�' => 'DH', '�' => 'dh', '�' => 'ss', '�' => 'OE', '�' => 'oe', '�' => 'AE', '�' => 'ae', '�' => 'u'));
    // ... and remove anything else that's not alphanumeric and replace it with an underscore.
    $string = preg_replace('/[^-\w]+/', '_', $string);
  }
  // Remove leading and trailing underscores.
  $string = trim($string, '_');
  // Finally, make it to lower case.
  return strtolower($string);
}


/**
 * Fetches an audio file, allows "shorthand" urls such of the form:
 * audio/view/$nid (e.g. audio/download/25/ or audio/download/14)
 *
 * @param $nid
 *   Node ID.
 */
function audio_download($nid = FALSE) {
  if ($nid && $node = node_load($nid)) {
    if (_audio_allow_download($node)) {
      // Increment the play count.
      db_query('UPDATE {audio} SET download_count = download_count + 1 WHERE vid = %d', $node->vid);

      // Downloading counts as "viewing" the node.
      node_tag_new($node->nid);

      // Notify other modules.
      audio_invoke_audioapi('download', $node);

      // The mime_header_encode function does not (yet) support
      // quoted-string encoding of ASCII strings with special
      // characters.  See discussion at http://drupal.org/node/82614
      $filename = $node->audio_file->origname;
      // If the string contains non-ASCII characters, process it through
      // the mime_header_encode function.
      if (preg_match('/[^\x20-\x7E]/', $filename)) {
        $filename = mime_header_encode($filename);
      }
      // Otherwise, if the string contains special characters (like
      // space), perform quoted-string encoding.
      elseif (preg_match('/[ \(\)<>@,;:\\"\/\[\]\?=]/', $filename)) {
        $filename = '"'. str_replace('"', '\"', $filename) .'"';
      }
      $headers = array(
        'Content-Type: '. mime_header_encode($node->audio_file->filemime),
        'Content-Length: '. $node->audio_file->filesize,
        'Content-Disposition: attachment; filename='. $filename,
      );
      audio_file_transfer($node->audio_file->filepath, $headers);
    }
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
}

/**
 * Similar to audio_download, but for streaming playback instead of download.
 *
 * @param $nid
 *   Node ID.
 */
function audio_play($nid = FALSE) {
  if ($nid && $node = node_load($nid)) {
    if (_audio_allow_play($node)) {
      // Increment the play count.
      db_query('UPDATE {audio} SET play_count = play_count + 1 WHERE vid = %d', $node->vid);

      // Playing counts as "viewing" the node.
      node_tag_new($node->nid);

      // Notify other modules.
      audio_invoke_audioapi('play', $node);

      $headers = array(
        'Pragma: public',
        'Expires: 0',
        'Cache-Control: must-revalidate, post-check=0, pre-check=0, private',
        'Content-Type: '. mime_header_encode($node->audio_file->filemime),
        'Content-Length: '. $node->audio_file->filesize,
        'Content-Disposition: inline;',
        'Content-Transfer-Encoding: binary',
      );
      // Required for IE, otherwise Content-disposition is ignored.
      ini_set('zlib.output_compression', 'Off');
      audio_file_transfer($node->audio_file->filepath, $headers);
    }
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
}

/**
 * Transfer a file to the client.
 *
 * Variation on Drupal's file_transfer() function. The only difference
 * is that set_time_limit() is called to allow for large files.
 *
 * @param $source
 *   String specifying the file to transfer.
 * @param $headers
 *   An array of http headers to send along with file.
 */
function audio_file_transfer($source, $headers) {
  ob_end_clean();

  foreach ($headers as $header) {
    // To prevent HTTP header injection, we delete new lines that are
    // not followed by a space or a tab.
    // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
    $header = preg_replace('/\r?\n(?!\t| )/', '', $header);
    header($header);
  }

  $source = file_create_path($source);

  // Transfer file in 1024 byte chunks to save memory usage.
  if ($fd = fopen($source, 'rb')) {
    if (!ini_get('safe_mode')){
      set_time_limit(0);
    }
    while (!feof($fd)) {
      print fread($fd, 1024);
      ob_flush();
      flush();
    }
    fclose($fd);
  }
  else {
    drupal_not_found();
  }
  exit();
}

/**
 * Create audio nodes from a file.
 *
 * Function for other modules to use to create a audio node from a file. Once
 * you've created it you can make any changes and then save it using
 * node_save().
 *
 * @param $filepath
 *   Full path to an audio file. be aware that the file will be moved into
 *   drupal's directory.
 * @param $title_format
 *   A t() formatting string for generating the node's title. you can use any
 *   value in the node's audio_tags array as variable. if nothing is provided
 *   the default title format will be used.
 * @param $tags
 *   An, optional, array of metadata to add to the node. these will be
 *   available to the $title_format.
 * @return
 *   A node or FALSE on error.
 */
function audio_api_insert($filepath, $title_format = NULL, $tags = array()) {
  global $user;

  // Check for user permission.
  if (!audio_access('create')) {
    drupal_access_denied();
  }

  $filepath = realpath($filepath);

  $node = new stdClass();
  $node->type = 'audio';
  $node->uid = $user->uid;
  $node->name = $user->name;

  // Set the node's defaults... (copied this from node and comment.module)
  $node_options = variable_get('node_options_'. $node->type, array('status', 'promote'));
  $node->status = in_array('status', $node_options);
  $node->moderate = in_array('moderate', $node_options);
  $node->promote = in_array('promote', $node_options);
  if (module_exists('comment')) {
    $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);
  }

  $node->title_format = $title_format;
  $node->audio_tags = array();
  $node->audio_images = array();

  $node->audio_file = new stdClass();
  $node->audio_file->newfile = TRUE;
  $node->audio_file->filename = basename($filepath);
  $node->audio_file->filepath = $filepath;
  if (function_exists('mime_content_type')) {
    $node->audio_file->filemime = mime_content_type($filepath);
  }
  else {
    // This may be a bad guess...
    $node->audio_file->filemime = 'audio/mpeg';
  }
  $node->audio_file->filesize = filesize($filepath);

  $node->audio_fileinfo = array(
    'downloadable' => variable_get('audio_default_downloadable', 1),
    'play_count' => 0,
    'download_count' => 0,
    'filesize' => $node->audio_file->filesize,
  );

  // Allow other modules to modify the node (hopefully reading in tags).
  audio_invoke_audioapi('upload', $node);

  // Add the tags (overwriting any that audio_getid3 may have loaded).
  if ($tags) {
    $node->audio_tags = $tags;
  }

  // ...then save it.
  $node->title = audio_build_title($node);
  $node = node_submit($node);
  node_save($node);

  return $node;
}

/**
 * Save the node's ID3 tags into the database.
 *
 * @param $node
 *   Node object.
 */
function _audio_save_tags_to_db($node) {
  $allowed_tags = audio_get_tags_allowed();

  // Remove any existing metadata.
  db_query("DELETE FROM {audio_metadata} WHERE vid=%d", $node->vid);

  // Save the new tags.
  foreach ($node->audio_tags as $tag => $value) {
    if (in_array($tag, $allowed_tags) && $value) {
      db_query("INSERT INTO {audio_metadata} (vid, tag, value, clean) VALUES (%d, '%s', '%s', '%s')",
        $node->vid, $tag, $value, audio_clean_tag($value));
    }
  }
}

/**
 * Parse an array into a valid urlencoded query string.
 *
 * This function is a work-around for a drupal_urlencode issue in core. 
 * See: http://drupal.org/node/158687 for details.
 *
 * @param $query
 *   The array to be processed e.g. $_GET.
 * @param $exclude
 *   The array filled with keys to be excluded. Use parent[child] to exclude
 *   nested items.
 * @param $parent
 *   Should not be passed, only used in recursive calls.
 * @return
 *   urlencoded string which can be appended to/as the URL query string.
 */
function audio_query_string_encode($query, $exclude = array(), $parent = '') {
  $params = array();

  foreach ($query as $key => $value) {
    $key = urlencode($key);
    if ($parent) {
      $key = $parent .'['. $key .']';
    }

    if (in_array($key, $exclude)) {
      continue;
    }

    if (is_array($value)) {
      $params[] = audio_query_string_encode($value, $exclude, $key);
    }
    else {
      $params[] = $key .'='. urlencode($value);
    }
  }

  return implode('&', $params);
}

/**
 * Determines if an audio node can be played by Flash players.
 *
 * @param $node
 *   Node object.
 * @return
 *   Boolean
 */
function audio_is_flash_playable($node) {
  // Flash only supports a limited range of sample rates.
  switch ($node->audio_fileinfo['sample_rate']) {
    case '44100': case '22050': case '11025':
      return TRUE;
    default:
      return FALSE;
  }
}

